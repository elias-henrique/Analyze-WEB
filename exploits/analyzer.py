"""
Analisador de vulnerabilidades de segurança
"""

import json
import re
import time
from datetime import datetime
from typing import Any, Dict, List
from urllib.parse import urljoin

import requests
from bs4 import BeautifulSoup


class SecurityAnalyzer:
    """Analisador de vulnerabilidades de segurança em aplicações web."""

    def __init__(self, base_url: str):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
        self.findings = {
            'timestamp': datetime.now().isoformat(),
            'target': base_url,
            'vulnerabilities': []
        }

    def log(self, message: str, level: str = "INFO") -> None:
        """Log formatado com cores."""
        colors = {
            'INFO': '\033[94m',
            'SUCCESS': '\033[92m',
            'WARNING': '\033[93m',
            'ERROR': '\033[91m',
        }
        reset = '\033[0m'
        timestamp = time.strftime('%H:%M:%S')
        print(f"{colors.get(level, '')}{timestamp} [{level}] {message}{reset}")

    def analyze_spa_routing(self) -> bool:
        """Analisa se todos endpoints retornam o mesmo conteúdo (SPA)."""
        self.log("Analisando roteamento SPA...")

        endpoints = ['/', '/dashboard', '/finance',
                     '/admin', '/.env', '/nonexistent']
        responses = {}

        for endpoint in endpoints:
            try:
                url = urljoin(self.base_url, endpoint)
                response = self.session.get(url, timeout=10)
                responses[endpoint] = {
                    'size': len(response.content),
                    'content': response.text[:500]
                }
            except Exception as e:
                self.log(f"Erro ao acessar {endpoint}: {str(e)}", "ERROR")

        sizes = set(r['size'] for r in responses.values())

        if len(sizes) == 1:
            self.log(
                f"Todos endpoints retornam mesmo conteúdo ({list(sizes)[0]} bytes)", "WARNING")
            self.log(
                "Aplicação usa Client-Side Routing (React/Next.js SPA)", "WARNING")

            self.findings['vulnerabilities'].append({
                'type': 'INFO',
                'title': 'Client-Side Routing Detectado',
                'severity': 'Informational',
                'description': 'Todos os endpoints retornam o mesmo HTML. O roteamento é feito no cliente.',
                'impact': 'Falsos positivos em scanners. Não há vulnerabilidade real.',
                'evidence': f'Todos endpoints retornam {list(sizes)[0]} bytes'
            })
            return True
        else:
            self.log("Endpoints retornam conteúdos diferentes", "SUCCESS")
            return False

    def test_missing_security_headers(self) -> None:
        """Testa ausência de headers de segurança."""
        self.log("Analisando headers de segurança ausentes...")

        try:
            response = self.session.get(self.base_url, timeout=10)
            headers = response.headers

            security_checks = {
                'X-Frame-Options': {
                    'severity': 'Medium',
                    'impact': 'Vulnerável a Clickjacking - site pode ser carregado em iframe malicioso'
                },
                'X-Content-Type-Options': {
                    'severity': 'Low',
                    'impact': 'Vulnerável a MIME type sniffing attacks'
                },
                'Content-Security-Policy': {
                    'severity': 'High',
                    'impact': 'Sem proteção contra XSS, injeção de scripts maliciosos'
                },
                'X-XSS-Protection': {
                    'severity': 'Low',
                    'impact': 'Sem proteção XSS em navegadores antigos'
                },
                'Referrer-Policy': {
                    'severity': 'Low',
                    'impact': 'Possível vazamento de informações via referrer'
                },
                'Permissions-Policy': {
                    'severity': 'Low',
                    'impact': 'Sem controle de features do navegador (camera, mic, etc)'
                }
            }

            for header, info in security_checks.items():
                if not headers.get(header):
                    self.log(
                        f"{header} ausente - Severidade: {info['severity']}", "WARNING")

                    self.findings['vulnerabilities'].append({
                        'type': 'MISSING_HEADER',
                        'title': f'Header de segurança ausente: {header}',
                        'severity': info['severity'],
                        'description': info['impact'],
                        'recommendation': f'Adicionar header: {header}'
                    })

        except Exception as e:
            self.log(f"Erro: {str(e)}", "ERROR")

    def test_clickjacking(self) -> None:
        """Testa vulnerabilidade de Clickjacking."""
        self.log("Testando Clickjacking...")

        try:
            response = self.session.get(self.base_url, timeout=10)

            if not response.headers.get('X-Frame-Options') and \
               not response.headers.get('Content-Security-Policy'):
                self.log("VULNERÁVEL a Clickjacking!", "WARNING")

                self.findings['vulnerabilities'].append({
                    'type': 'CLICKJACKING',
                    'title': 'Vulnerabilidade de Clickjacking',
                    'severity': 'Medium',
                    'description': 'Site pode ser carregado em iframe, permitindo ataques de clickjacking',
                    'impact': 'Atacante pode sobrepor elementos invisíveis e enganar usuários',
                    'recommendation': 'Adicionar header: X-Frame-Options: DENY ou SAMEORIGIN'
                })
            else:
                self.log("Protegido contra Clickjacking", "SUCCESS")

        except Exception as e:
            self.log(f"Erro: {str(e)}", "ERROR")

    def test_cors_misconfiguration(self) -> None:
        """Testa configuração CORS."""
        self.log("Testando configuração CORS...")

        try:
            response = self.session.get(self.base_url, timeout=10)
            cors_header = response.headers.get('Access-Control-Allow-Origin')

            if cors_header == '*':
                self.log(
                    f"CORS configurado para permitir qualquer origem (*)", "WARNING")

                self.findings['vulnerabilities'].append({
                    'type': 'CORS_MISCONFIGURATION',
                    'title': 'CORS Permissivo',
                    'severity': 'Medium',
                    'description': 'Access-Control-Allow-Origin: * permite requisições de qualquer origem',
                    'impact': 'Dados podem ser acessados por sites maliciosos',
                    'evidence': f'Header: {cors_header}',
                    'recommendation': 'Restringir CORS apenas a domínios confiáveis'
                })
            elif cors_header:
                self.log(f"CORS configurado para: {cors_header}", "SUCCESS")
            else:
                self.log("CORS não configurado", "SUCCESS")

        except Exception as e:
            self.log(f"Erro: {str(e)}", "ERROR")

    def test_information_disclosure(self) -> None:
        """Testa vazamento de informações."""
        self.log("Testando vazamento de informações...")

        try:
            response = self.session.get(self.base_url, timeout=10)

            info_headers = {
                'Server': response.headers.get('Server'),
                'X-Powered-By': response.headers.get('X-Powered-By'),
                'X-Vercel-Id': response.headers.get('X-Vercel-Id'),
                'X-Vercel-Cache': response.headers.get('X-Vercel-Cache'),
            }

            disclosed = {k: v for k, v in info_headers.items() if v}

            if disclosed:
                self.log("Informações expostas nos headers:", "WARNING")
                for header, value in disclosed.items():
                    self.log(f"  {header}: {value}", "INFO")

                self.findings['vulnerabilities'].append({
                    'type': 'INFORMATION_DISCLOSURE',
                    'title': 'Vazamento de Informações via Headers',
                    'severity': 'Low',
                    'description': 'Headers revelam informações sobre infraestrutura',
                    'evidence': disclosed,
                    'impact': 'Facilita reconnaissance para ataques direcionados',
                    'recommendation': 'Remover ou ofuscar headers informativos'
                })

        except Exception as e:
            self.log(f"Erro: {str(e)}", "ERROR")

    def generate_report(self) -> Dict[str, Any]:
        """Gera relatório de vulnerabilidades."""
        self.log("\n" + "="*60)
        self.log("RESUMO DE VULNERABILIDADES")
        self.log("="*60)

        severity_count = {'High': 0, 'Medium': 0, 'Low': 0, 'Informational': 0}

        for vuln in self.findings['vulnerabilities']:
            severity = vuln.get('severity', 'Low')
            severity_count[severity] = severity_count.get(severity, 0) + 1

        self.log(
            f"\nTotal de achados: {len(self.findings['vulnerabilities'])}")
        self.log(f"  High: {severity_count.get('High', 0)}")
        self.log(f"  Medium: {severity_count.get('Medium', 0)}")
        self.log(f"  Low: {severity_count.get('Low', 0)}")
        self.log(f"  Informational: {severity_count.get('Informational', 0)}")

        return self.findings

    def run_analysis(self) -> Dict[str, Any]:
        """Executa análise completa."""
        self.log("="*60)
        self.log(f"Iniciando análise de segurança: {self.base_url}")
        self.log("="*60)

        self.analyze_spa_routing()
        self.test_missing_security_headers()
        self.test_clickjacking()
        self.test_cors_misconfiguration()
        self.test_information_disclosure()

        return self.generate_report()
